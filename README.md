# Desafio Técnico Frontend React - Porter

Salve pessoal da Porter! Sou o Jota e esta é a minha proposta de solução para o Desafio Técnico de vocês. Nesse readme vocês poderão acompanhar as decisões que tomei durante o projeto, o contexto envolta delas, documentação relativa a estrutura do repositório, como rodar a aplicação, etc.

>_Gostaria de registrar aqui que me comprometo em não utilizar IA nesta parte documental por entender que conseguir sustentar minhas escolhas e explicá-las é uma das partes mais importantes nesse tipo de avaliação._

---

## Primeiras impressões

O desafio é bem objetivo - viabilizar o consumo de dados de uma API, permitir interações básicas dentro da aplicação e gerenciamento de estado. Minha leitura dessa proposta é que devo prezar por adotar boas práticas e, principalmente, colocar em evidência meu conhecimento sobre elas.

Além disso, acredito que seja fundamental implementar os diferenciais técnicos. É uma boa forma de ir além e mostrar habilidades que possuo. Vou documentar no tópico de decisões as minhas expectativas de tecnologias e ferramentas que pretendo adotar.

Neste último final de semana participei do Front in Floripa e curti a proposta apresentada pelo Vedovelli para uso de IA nos seus projetos. Assim, passei o desafio técnico para o Claude e pedi para ele elaborar um PRD que servirá de referência ao agente para me ajudar durante o desenvolvimento.

## Diário

> 20/11 (~18h): Terminei o esboço do README. Coloquei minhas primeiras impressões, escolhas de ferramentas e minhas opiniões sobre alguns tópicos. Agora pretendo avançar na criação da aplicação. Fazer o bootstrap com Vite, ajustes de tooling (Biome) e em seguida já garantir a internacionalização com react-i18next e a containeirização com Docker. Assim já deixo dois diferenciais técnicos bem encaminhados.
> 20/11 (~20h30): Para a implementação do Docker, resolvi adotar as boas práticas de ter um processo multistep para instalar dependências + buildar a aplicação e, a partir dos arquivos gerados em /dist, servir a aplicação através de uma imagem NGINX. Já em termos de i18n, implementei a ferramenta seguindo a documentação da mesma e mantendo defaults (como namespace). Adicionei também um arquivo de declaração de tipos para utilizar somente mensagens existentes, assim melhorando a DX com Typescript.
> 20/11 (21h): Vou utilizar a ferramenta UXPilot para gerar um design referência para essa entrega. Vou adicionar na pasta /docs depois o prompt usado e prints contendo os resultados.
> 21/11 (12h): Agora vou focar na parte que acredito que pode demorar um pouco mais de tempo: configurar o Apollo Client e garantir o consumo dos dados que vou precisar, conforme orientação dada pelo PDF do desafio + design de referência.
> 21/11 (13h30): Passei a última hora e meia lendo a documentação do Apollo Client. Gostei muito do que li sobre o uso de Suspense e maneiras de manipular o carregamento de queries - pretendo usar isso para fazer certas otimizações. Mas a cereja do bolo foi descobrir a existência do GraphQL Codegen. Fiz alguns testes e, pelo visto, ele é compatível com os schemas disponibilizados pela API do Rick and Morty. Vou investir um tempo nisso já que um dos critérios do desafio é o uso bem feito de TS.
> 21/11 (17h): Com algumas pausas e leituras de documentação, fiz o setup do Styled Components junto de um tema base para a aplicação. Agora é hora de começar a dar vida a UI, já que já consigo consumir a API do GraphQL. 
> 22/11 (09h): Ontem, explorei ideias de implementação, testando queries e formas de montar a página. Depois dessa exploração, deletei quase todos os arquivos e agora pretendo começar a fazer a construção da página de baixo para cima - vou começar fazendo renderizar os cards dos personagens, e depois avanço para a parte dos filtros.
> 22/11 (16h): Implementei o primeiro grupo de requisitos que é a tela de usuários. Gastei um tempo para adicionar transições, refatorar para utilizar o useSuspenseQuery e garantir uma boa UX. Agora, pretendo implementar os filtros de maneira crua, sem funcionalidade, depois instalar o Zustand e configurar a store para salvar o estado dos filtros e torná-los funcionais.
> 22/11 (18h30): Store de filtros criadas e input de pesquisa por nome já operando. O foco agora é construir a funcionalidade de favoritos. Vou deixar o modal de detalhes do personagem pro fim já que deve ser uma parte mais tranquila.
> 22/11 (20h): Criei a store de favoritos e enfrentei uma das maiores refatorações até aqui - separar a lógica de buscar os personagens da camada de apresentação para garantir um código DRY. Isso permitiu fazer uma renderização condicional a depender do filtro selecionado, buscar os dados necessários, e manter um lugar centralizado para a apresentação com uma única instanciação de paginação, cards e grid (critério de reutilização de componentes). Também adicionei um toast para atender o requisito do desafio de feedback ao usuário.
> 23/11 (15h): Implementei o modal de detalhes do usuário. Essa parte já foi bem mais intuitiva. Implementei um Error Boundary nele também para, em caso de erro das requests, mostrar um erro ao usuário sem impedir que ele continue usando a aplicação que já havia carregado. Adotei o uso da Suspense query com retorno de dados parciais em caso de termos já em memória cacheado algumas das coisas presentes na query. Também fiz alguns ajustes para manter a a11y dos cards.

## Decisões técnicas

- Utilizar a API Suspense do React para garantir uma boa UX. Durante o primeiro carregamento, temos um spinner que preenche a tela enquanto carregam-se os dados. Após, durante o uso da paginação, utilizamos a API do useTransition para manter a tela funcional enquanto os dados não foram carregados - temos um spinner junto ao botão de paginação para indicar que novos dados estão sendo carregados e, enquanto isso, os cards da página "antiga" seguem presentes.
- Utilizar Debounce para evitar sobrecarga de requisições e prejudicar a UX quando pesquisar personagem por nome.
- Utilizar Map dentro da Store de favoritos para persistir cada personagem indexado a partir de seu ID. Isso torna operações de acesso, adição e deleção mais simples.
- Salvar o timestamp do momento em que se favoritou um personagem para permitir implementações futuras de reconciliação/refetch com a API externa.
- Pensei em converter os cards em buttons para acionar o modal de mais dados, mas a especificação do HTML não permite nested buttons. Assim, segui utilizando uma div mas fiz alguns ajustes com atributos ARIA, role e manipulando eventos de teclado. Isso é importante para manter a acessibilidade (a11y), permitindo a navegação através de teclado e oferecendo ao usuário informações do que aquele elemento faz.
- Implementei o modal utilizando o elemento nativo do HTML Dialog. Com ele, já temos garantidos vários recursos de acessibilidade e também seguimos boas práticas de adotar um elemento apropriado existente. Para controlá-lo, temos que utilizar o useEffect para controlar sua API de abertura e fechamento (o controle através do atributo open não adiciona backdrop). Este é um dos poucos casos em que o useEffect é aceitável conforme a [documentação do React](https://react.dev/reference/react/useEffect#controlling-a-non-react-widget).

### Sobre as Ferramentas e tecnologias:

- React: Como essa será uma aplicação bem simples, não vejo necessidade de construir a aplicação com um framework como Tanstack / Next / etc. SSR é algo cada vez mais importante no cenário atual de performance de aplicações React, mas também existe um overhead no setup inicial que não acho que seja necessário para esse caso. Posso aprofundar esse tema posteriormente na conversa técnica. Portanto, acredito que o melhor para esse caso é criar uma SPA usando **Vite**
- Consumo de dados: aqui pretendo implementar o diferencial técnico de usar **GraphQL**. Tenho uma certa familiaridade com o assunto mas nunca utilizei o Apollo Client - boa oportunidade para demonstrar adaptabilidade. Além disso, olhando rapidamente na documentação, a biblioteca já possui APIs necessárias para atingir certas demandas do desafio - como loading state e tratativa de erros.
- Gerenciamento de estado: o gerenciamento de estado está principalmente ligado ao requisito funcional dos usuários favoritos. Temos 3 opções de bibliotecas, vou comentar rapidamente minha visão sobre elas.
  - A Context API é muito boa para resolver o problema "prop drilling" no React - ou seja, compartilhar um estado que possa ser utilizado em vários pontos da aplicação. Seu setup é um pouco verboso e, mesmo sendo possível implementar lógicas mais complexas com reducers, acredito que seu valor de uso está para casos pontuais como por ex. persistir o tema do usuário - dados de natureza mais "atômico" e não tão estruturados.
  - O Redux era a ferramenta padrão para gerenciamento de estado até algum tempo atrás. A partir de uma store global, temos um controle muito mais fino sobre o consumo e publicação de mudanças. No meu jeito de ver, possui uma API um pouco mais burocrática e não intuitiva, mesmo com o mais recente RTK. O setup inicial também é mais custoso.
  - O Zustand se tornou rapidamente um xodó dos devs já que possui uma API bem intuitiva e uma facilidade grande no setup inicial. Quando li o desafio, já estava convencido que iria utilizar ela, principalmente considerando o aspecto tempo de implementação. Lendo rapidamente o readme deles agora, vi que já existe até uma seção documentando a persistência dos dados do estado no localStorage do navegador, outro requisito do desafio. **Zustand** é minha escolha.
- Estilos: vou seguir a indicação do Styled Components.
